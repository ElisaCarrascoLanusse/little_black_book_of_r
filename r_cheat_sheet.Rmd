---
title: "r_cheat_sheet"
output: html_notebook
---

# BASICS -----------------------------------------
```{r}
# Mathematical symbols work as you would expect them to
object_name <- value # Creates an object: <- (option + -)
primes <- c(2, 3, 5, 7, 11, 13) # Combines multiple elements into vector (c())

i_use_snake_case
otherPeopleUseCamelCase
some.people.use.periods
And_aFew.People_RENOUNCEconvention

# Pipes
df |> # Pipes are extra helpful when writing big chunks
  function() 

function_name(argument1 = value1, argument2 = value2, ...) # Function generally have this structure

```

# KEY FUNCTIONS (RUN THIS BITCH) ---------------------------------------
```{r}
# key_packages_fn - These are packages I tend to work with often. We are installing and setting up collectivly.
key_packages_fn <- function() {
  # List of packages
  key_packages <- c("tidyverse", "readr", "dplyr", "ggplot2", "rmarkdown", "xml2", "plotly", "shiny", "ggthemes", "janitor", "styler", "arrow", "ggsci", "rstudioapi")
  # Check if each package is installed, and install it if not
  for (pkg in key_packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      install.packages(pkg)
    }
    # Load the package
    library(pkg, character.only = TRUE)
  }
}

# Call the function
key_packages_fn()

janitor::clean_names() # Great for cleaning up names

```

# SETUP
```{r}
data_frame <- read_csv("name.csv", na = c("N/A", "") | data_frame <- read_csv("https", na = c("N/A", "") # Clears na
                                                                              
# Types of reads
    read_csv2() # Reads semicolon-separated files. These use ; instead of , to separate fields and are common in countries that use , as the decimal marker.

    read_tsv() # Reads tab-delimited files.

    read_delim() # Reads in files with any delimiter, attempting to automatically guess the delimiter if you don’t specify it.

    read_fwf() # Reads fixed-width files. You can specify fields by their widths with fwf_widths() or by their positions with fwf_positions().

    read_table() # Reads a common variation of fixed-width files where columns are separated by white space.

    read_log() #Reads Apache-style log files.

write_csv(df, "df.csv")

# Set working diretory
setwd("/Users/elisacarrasco/Desktop")

# Set directory for data frame and file paths
directory_name <- "/Users/elisacarrasco/Desktop/Name"
name_paths <- list.files(directory_name, pattern = ".filetype", full.names = TRUE)
name_list <- lapply(name_paths, read_filetype)

# Combine all data frames into one and view
name_df <- do.call(rbind, name_list)
print(name_df)
View(name_df)
```

# DATA ENTRY
```{r}
tribble( # A tribble can be entered by hand, defining the columns (variables) and the rows (values)
  ~x, ~y, ~z,
  1, "h", 0.08,
  2, "m", 0.83,
  5, "g", 0.60)


```

# READR --------------------------------------------
```{r}
# Column Types
col_logical() # Reads logicals and real numbrs
col_integer() # Reads integers
col_character() # Reads strings
col_factor() # Create factors
col_date() # Create dates
col_datetime() # Create date-times
col_number() # Ignores non-numeric components, useful for currencies
col_skip() # Skips column so it's not included
cols_only() # Reads only specified columns
```
# TIDYVERSE --------------------------------------------
```{r}
install.packages("tidyverse")
library(tidyverse)

# Rules of tidyverse: Each variable is a column; each column is a variable.   Each observation is a row; each row is an observation.  Each value is a cell; each cell is a single value.

pivot_longer(cols = parameter), 
    names_to = "columnname", 
    values_to = "columnname", 
    values_drop_na = TRUE) # cols specifies which columns need to be pivoted, i.e. which columns aren’t variables.   names_to names the variable stored in the column names.   values_to names the variable stored in the cell values.

pivot_wider(
    id_cols = # Which columns are being used,
    names_from = # Where the names are taken from,
    values_from = # Where the data is from
  )
```
- df = data frame
Rules of tidy data:
    Each variable is a column; each column is a variable.
    Each observation is a row; each row is an observation.
    Each value is a cell; each cell is a single value.


# DPLYR ----------------------------------------------
```{r}
ungroup()
flights |>
  filter(dest == "IAH") |> 
  group_by(year, month, day) |> 
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE)
  )

|> or %>% (command + shift + m) # This is a pipe, takes the thing on its left and passes it along to the function on its right so that x |> f(y) is equivalent to f(x, y), and x |> f(y) |> g(z) is equivalent to g(f(x, y), z)

# Rows
filter() # Changes which rows are present without changing their order
  # Use greater than >, greater than or equal >=, less than <, less than or equal <=, equal to ==, not equal to !=, and &, or |.
  # %in% Keeps rows where the variable equals one of the values on the right.
arrange() # Changes the order of the rows without changing which are present
  # arrange(desc()) Arranges the data in the column in descending order
distinct() # Finds all the unique rows in a dataset
count() # Counts the number of ocurrences of each row

# Columns
mutates() # Add new columns that are calculated from the existing columns
  # .before and .after can be used to dictate where the new column is placed in relation to an existing column
  # .keep Dictates which columns are displayed. .keep = used specifies that we only keep the columns that were involved
select() # Zoom in on a useful subset using operations based on the names of the variables
  # starts_with("abc"): matches names that begin with “abc”.  ends_with("xyz"): matches names that end with “xyz”.   contains("ijk"): matches names that contain “ijk”.  num_range("x", 1:3): matches x1, x2 and x3.
rename() 
relocate() # 

# Groups
group_by() # Divide dataset into groups meaningful
summarize() 
slice_ # df |> slice_head(n = 1) takes the first row from each group.   df |> slice_tail(n = 1) takes the last row in each group.   df |> slice_min(x, n = 1) takes the row with the smallest value of column x.  df |> slice_max(x, n = 1) takes the row with the largest value of column x.   df |> slice_sample(n = 1) takes one random row.
ungroup()

```
Dplyr structure: The first argument is always a data frame.  The subsequent arguments typically describe which columns to operate on using the variable names (without quotes).   The output is always a new data frame.

# GGPLOT -------------------------------------------
```{r}
## General structure
name_plot <- ggplot(
  dfname, aes(x = xname, y = yname)) +
  geom_graphtype(aes(color = variable_a, shape = variable_b)) + # Sometimes a geom_type will have different usage methods -> geom_smooth(method = lm)
  labs(
    title = "Title",
    subtitle = "Subtitle",
    x = "Variable A (metric)", y = "Variable B (metric)",
    color = "Variable C", shape = "Variable C") +
  scale_color_colorblind() # Accessible colors, might not be necessary if using different shapes

# Types of plots
Bar A (categorical data) <- ggplot(df, aes(x = fct_infreq(variable))) + ## fct_ sets order of categorical variables, infreq is frequency based
  geom_bar() 

Bar B (frequencies) <- ggplot(df, aes(x = variable, fill = variable)) +
  geom_bar()

Bar C (relative freq) <- ggplot(df, aes(x = variable, fill = variable)) +
  geom_bar(position = "fill")

Boxplot (categorical and numerical) <- ggplot(df, aes(x = variable, y = variable)) +
  geom_boxplot()

Density A (numerical data) <- ggplot(df, aes(x = variable)) +
  geom_density(linewidth = number)

Density B (numerical) <- ggplot(df, aes(x = variable, color = variable, fill = variable)) +
  geom_density(alpha = number)

Histogram (numerical) <- ggplot(df, aes(x = variable)) +
  geom_histogram(binwidth = size)

Scatterplot (numerical, 3+ variables) <- ggplot(df, aes(x = variable_1, y = variable_2)) +
  geom_point(aes(color = variable_3, shape = variable_4)) # Using facet_wrap cleans up graphs like these into subsets :)

# Faceting - Displays subset of data
faceted_plot <- ggplot(df, aes(x = variable_1, y = variable_2)) +
  geom_point(aes(color = variable_3, shape = variable_3)) +
  facet_wrap(~variable_4)

# Saving Plots
ggsave(filename = "filename.png")
```


